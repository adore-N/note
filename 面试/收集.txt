1.let const 
	.1不存在变量提升
	.2暂时性死区
	.3不允许重复声明
	.4块级作用域

2.解构赋值的应用场景?
	.1交换变量的值
	.2从函数返回多个值
	.3函数参数的定义
	.4提取json数据
	.5函数参数的默认值
	.输入模块的指定方法

3.字符串的扩展
	.1 unicode表示法 "\u0061" === "a"
	.2字符串的遍历器接口 Iterator
	.3 JSON.stringify()改造
	.4模板字符串 ` `

4.字符串的API(原生的只有indexOf)
	.1  includes()：返回布尔值，表示是否找到了参数字符串。
		startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
		endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
	.2 repeat(): 返回一个新字符串,表示将原字符串重复n次

5.函数的扩展
	.1 rest参数(形式为...变量名),用于获取函数的多余参数,不需要使用arguments
	.2 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
		解决方案:全局设置严格模式 
	.3 name属性:表示函数名(早就要,但是没写入标准)

6.箭头函数
	表达更加简洁
	简化回调函数

7.箭头函数有几个使用注意点。

（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。(this指向外层作用于)

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。

8.什么是尾调用？
	尾调用（TailCall）是函数式编程的一个重要概念，
	本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

9.数组的扩展
	扩展运算符 ...
		应用场景: 复制数组 合并数组 与解构赋值结合  字符串->数组

	array.from(): 对象->数组
	array.of(): 一组数值->数组

10.属性的遍历
	（1）for...in
		for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

	（2）Object.keys(obj)
		Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
	
	（3）Object.getOwnPropertyNames(obj)
		Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
	
	（4）Object.getOwnPropertySymbols(obj)
		Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
	
	（5）Reflect.ownKeys(obj)
		Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。








webpack模块热重载